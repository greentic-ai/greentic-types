PR: greentic-types – 0.6.0 Core Types (Canonical CBOR, Schema IDs, Self-Describing Ops, I18nId, QA Embedding)

Base branch: release/0.6.0
Do not change master for breaking work. Urgent fixes land in master then cherry-pick.

Goal

Provide shared Rust types + helpers that make 0.6.0 convenient everywhere:

Canonical CBOR encoding/decoding and enforcement (stable IDs)

Schema IDs + schema references (for self-describing op I/O and validation)

Self-describing op descriptor Rust mirrors (aligned with greentic-interfaces PR-B)

I18nId + I18nTag + minimal I18nProfile

QA setup contract embedding types (aligned with greentic-interfaces PR-A)

This crate is the “one place” other repos import to avoid re-inventing wrappers, IDs, CBOR policies, and descriptor structs.

Design constraints

CBOR is the wire + artifact format for 0.6.0 boundaries.

Canonical CBOR must be deterministic across platforms.

Default policy: string-only map keys, no floats, unless explicitly enabled.

IDs are derived from canonical CBOR + stable hashing.

Keep JSON support only for transition/debug; core paths are CBOR-first.

Encoding decision

IDs (schema, i18n, etc.) use Crockford Base32 (`0-9` + `A-Z` excluding `I/L/O/U`, uppercase, no padding). Helpers expose `encode_base32_crockford`/`decode_base32_crockford`, and canonical hashes are serialized through this alphabet so CLI logging/human hand-off stays safe.

JSON compatibility policy

`SchemaSource::InlineJson` and QA `InlineJson` variants stay available for tooling but live behind `json-compat`. Treat them as transition-only (flag them deprecated once consumers migrate); the canonical path is CBOR-first.

Work items
1) Canonical CBOR module

Add cbor::canonical:

API

fn to_canonical_cbor<T: Serialize>(value: &T) -> Result<Vec<u8>>

fn from_cbor<T: DeserializeOwned>(bytes: &[u8]) -> Result<T>

fn ensure_canonical(bytes: &[u8]) -> Result<()>

re-encode parsed value canonically and compare bytes; error if mismatch

fn canonicalize(bytes: &[u8]) -> Result<Vec<u8>>

parse then re-encode canonical (useful for normalizing incoming)

Canonical rules (MVP but strict)

deterministic map key ordering

forbid non-string map keys

forbid floats by default

consistent integer encoding (canonical form)

reject indefinite-length encodings unless you already standardize them

If you already have a CBOR lib choice elsewhere, use the same one. The key is deterministic output.

Hash/id helpers

fn blake3_128(bytes: &[u8]) -> [u8; 16]

fn encode_b32(bytes: &[u8]) -> String (base32 or base64url—pick one and standardize)

fn decode_b32(s: &str) -> Result<Vec<u8>>

Acceptance

Canonical CBOR is stable and enforceable with ensure_canonical.

2) First-class CBOR wrappers (ergonomics + safety)

Introduce lightweight newtypes:

pub struct CborBytes(pub Vec<u8>);

methods:

fn ensure_canonical(&self) -> Result<()>

fn canonicalize(self) -> Result<CborBytes>

fn decode<T: DeserializeOwned>(&self) -> Result<T>

pub struct Blob { pub content_type: String, pub bytes: Vec<u8> } (optional)

If you don’t want Blob, keep content_type on schema structs below.

Acceptance

Other repos can stop passing raw Vec<u8> around for CBOR payloads.

3) Schema IDs + schema sources (invoke-time and QA-time)
3.1 SchemaId

Add a stable identifier type:

pub struct SchemaId(String); with prefix like:

schema:v1:<b32(blake3_128(canonical_schema_cbor))>

Provide:

impl SchemaId { fn parse(s: &str) -> Result<Self>; fn as_str(&self)->&str }

fn schema_id_for_cbor(schema_cbor: &[u8]) -> Result<SchemaId>

canonicalize or enforce canonical before hashing

3.2 SchemaSource

Unify schema references used across:

invoke-time op I/O description

QA setup answers schema

pub enum SchemaSource {
  CborSchemaId(SchemaId),
  InlineCbor(CborBytes),
  InlineJson(String),     // transition/debug only
  RefPackPath(String),
  RefUri(String),
}


If you want to avoid mixing QA vs invoke, add type aliases:

pub type QaSchemaSource = SchemaSource;

pub type IoSchemaSource = SchemaSource;
or separate enums with identical variants.

Acceptance

SchemaId exists and is derived from canonical CBOR.

Schema sources cover id/inline/path/uri.

4) Self-describing op descriptor Rust mirrors (aligned with greentic-interfaces PR-B)

Add Rust structs mirroring the WIT descriptor changes for invoke-time ops:

pub struct IoSchema {
  pub schema: SchemaSource,
  pub content_type: String, // default "application/cbor"
}

pub struct OpExample {
  pub title: String,
  pub input_cbor: CborBytes,
  pub output_cbor: Option<CborBytes>,
  pub notes: Option<String>,
}

pub struct OpDescriptor {
  pub name: String,
  pub summary: Option<String>,
  pub input: IoSchema,
  pub output: IoSchema,
  pub examples: Vec<OpExample>,
}


If your component descriptor type already exists in greentic-types, extend it with:

ops: Vec<OpDescriptor>

If descriptor lives elsewhere, keep these as standalone “shared shapes” to be embedded by other crates.

Acceptance

These types compile, serialize cleanly, and can be used by pack/flow/runner tooling.

5) I18n identifiers + minimal profile (CBOR-first)
5.1 I18nTag

canonical locale tag string (BCP 47 + optional -u- extensions)

Provide:

fn normalize_tag(input: &str) -> Result<I18nTag>

5.2 I18nId

i18n:v1:<b32(blake3_128(canonical_cbor(tag or minimal profile)))>

Provide:

impl I18nId { fn parse(&str) -> Result<Self>; fn as_str(&self)->&str }

fn id_for_tag(tag: &I18nTag) -> Result<I18nId>

Clarify that 0.6.0 uses normalized `I18nTag`s (not the richer profile) to derive IDs—normalize once, then hash the canonical tag string so everyone gets the same identifier before we layer richer profile info later.

5.3 Minimal I18nProfile

Fields you’ll use early:

language, region, script (optional)

direction (ltr/rtl)

calendar

currency

decimal_separator

timezone (optional but recommended)

Ensure:

Serialize + stable canonical CBOR encoding (no floats etc.)

Acceptance

Stable ID generation and parse/format roundtrip.

6) QA setup embedding types (aligned with greentic-interfaces PR-A)

Add types mirroring setup contract:

QaSpecSource (InlineCbor / InlineJson / RefUri / RefPackPath)

ExampleAnswers { title, answers_cbor: CborBytes, notes }

SetupOutput (ConfigOnly / TemplateScaffold { template_ref, output_layout })

SetupContract { qa_spec, answers_schema: Option<SchemaSource>, examples, outputs } (optional convenience)

Add:

fn validate_answers(schema: &SchemaSource, answers_cbor: &CborBytes) -> Result<()>

For 0.6.0 MVP:

decode CBOR and require it’s a map/object

optionally enforce canonical if used for examples/ids

Keep API stable for later real schema engine integration.

Update the signature to accept a `CanonicalPolicy` (Off / RequireCanonical / Canonicalize) so interactive validation can skip canonical checks while examples/ID generation can insist on canonical bytes or re-emit them.

Acceptance

Setup types serialize/deserialize, and example answers are CBOR-first.

Tests
Canonical CBOR

golden test: canonical encoding stable for a representative map

test: ensure_canonical fails on non-canonical equivalent encoding

test: canonicalize normalizes to canonical bytes

Schema IDs

test: schema_id_for_cbor stable for a sample schema CBOR

test: SchemaId::parse roundtrip

I18n

test: normalize_tag("en-gb") == "en-GB"

test: id_for_tag("en-GB-u-ca-gregory-cu-gbp") stable

test: I18nId parse/format roundtrip

Setup + ops

test: OpDescriptor and SetupContract serialize/deserialize

test: validate_answers accepts a CBOR map, rejects non-map

Acceptance criteria

Other repos can adopt 0.6.0 without inventing new CBOR wrappers/IDs.

Canonical CBOR + ID generation is stable and enforced.

Schema IDs + sources exist for self-describing op I/O and QA answers schemas.

Self-describing op types are available for pack/flow/runner tooling.

JSON support exists only for transition/debug; core path is CBOR-first.
